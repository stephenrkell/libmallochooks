# whitespace-separated: can have more than one
BUILD_MALLOC_HOOKS ?= noop
# must have exactly one method!
MALLOC_HOOKS_METHOD ?= preload

# What's supposed to happen: we generate one .o file for each named set of hooks
# (e.g. "noop" above), each specialised for "method". That .o file is built from
# one copy of malloc_hook_stubs_${method}.c *per hook* -- each copy is compiled
# with different CFLAGS so that it calls the next in the chain, or the "terminal"
# hook if there is no next.
# PROBLEM: we can't generate .o files amenable to LTO if we use the defsym trick.
# So we generate a .c file and emit the LDFLAGS for the corresponding .o file.
# PROBLEM: if a client wants to use more than one method, they probably don't
# want to include this Makerules file, but instead use $(MAKE) -f to "call" it,
# but then we can't set LDFLAGS in the including makefile.

# add the path of this makefile to vpath
# (since we assume we're being included from the build dir)
THIS_MAKEFILE := $(lastword $(MAKEFILE_LIST))

# we no longer provide rules for building .o files, owing to the LTO
# problem mentioned below. We only build .c files, and define appropriate LDFLAGS.
vpath %.c  $(dir $(realpath $(THIS_MAKEFILE)))
CFLAGS += -I$(dir $(realpath $(THIS_MAKEFILE)))

# building the actual hooks
# FIXME: iterative version for multiple hooks
# NOTE that using --defsym to plumb together __next_hook*, which is what we'd like,
# is incompatible with link-time optimisations (LTO), at least for current gcc/binutils
# implementations of LTO. So instead we have to use the preprocessor to define __next_hook_*.
# So we don't define how to build .o files at all.

comma := ,

# We understand at least three hooking methods.
# 1. Use glibc's hook infrastructure
# 2. LD_PRELOAD a shared library containing malloc, free et al. 
# 3. static-link an object defining malloc, free et al.
#
# Option 2 is tricky because we have to use dlsym to get the
# underlying malloc, free etc.. And dlsym calls malloc! To
# get around this, we include a configurable chunk of bss that
# supports an early_malloc, early_free etc.. Only when our
# dlsym has succeeded do we switch to using the real malloc.

# Set global linker options appropriate for the method we're using.
ifeq ($(MALLOC_HOOKS_METHOD),wrap)

# Modify the including Makefile's LDFLAGS so that 
# - malloc and friends are --wrap'ped
# - for good measure (FIXME: why?) define __real_* to be aliases of the unprefixed
# - (recall: --wrap only affects the undefined symbols in any given linker input file,
#    so normally the linker output never actually contains a symbol called __real_*.)

LDFLAGS += $(prefix -Wl$(comma)--wrap$(comma),malloc calloc free realloc memalign posix_memalign)
LDFLAGS += $(prefix -Wl$(comma),\
--defsym __real_malloc=malloc \
--defsym __real_calloc=calloc \
--defsym __real_free=free \
--defsym __real_realloc=realloc \
--defsym __real_memalign=memalign \
--defsym __real_posix_memalign=posix_memalign)

# We don't know whether the user wants fast or "normal" hooks, so don't modify ldlibs
# LDLIBS += 

else
ifeq ($(MALLOC_HOOKS_METHOD),preload)

# don't modify the linker flags, 
# but DO rename our [first] hooks to their rightful names.
# How? FIXME: we don't support chaining multiple hooksets yet.
# NOTE: we *do* use these preload hooks -- although this block is
# empty, the preload case is functional. In liballocs, malloc et al
# are defined in malloc_hook_stubs_preload.o.

else
ifeq ($(MALLOC_HOOKS_METHOD),glibc)

# glibc implies building a preloadable library
# -- hmm, glibc malloc hooks are pretty obsolete, so no impl provided

endif # glibc
endif # preload
endif # wrap
